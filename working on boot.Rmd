---
title: "Comparing internal and boot package bootstrapping"
author: "Megan Jones"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# current RESI
library(RESI)

# fit example model
mod1 = glm(formula = charges ~ region * age + bmi + sex, data = RESI::insurance)

# use internal bootstrapping
set.seed(123)
t1 = Sys.time()
resi_internal = resi(mod1, store.boot = TRUE)
t2 = Sys.time()
dt = difftime(t2, t1)
dt
```

```{r}
# try using boot package and new functions
library(boot)

resi_stat = function(dat, inds, mod.full, mod.reduced, ...){
  mod = update(mod.full, data = dat[inds,])
  if (is.null(mod.reduced)){
    mod.red = NULL} else{
      mod.red = update(mod.reduced, data = data[inds,])
    }
  out = resi_pe(mod, model.reduced = mod.red, data = dat[inds,], ...)$estimates
  return(out)
}

resi_boot <- function(model.full, ...){
  UseMethod("resi_boot")
}

resi_boot.default <- function(model.full, model.reduced = NULL, data, anova = TRUE,
                         coefficients = TRUE, nboot = 1000,
                         vcovfunc = sandwich::vcovHC, alpha = 0.05, store.boot = FALSE,
                         Anova.args = list(), vcov.args = list(), unbiased = TRUE,
                         parallel = c("no", "multicore", "snow"), ncpus = getOption("boot.ncpus", 1L),
                         ...){
  dots = list(...)
  if ("boot.method" %in% names(dots)){
    message("Only nonparametric bootstrap supported for model type")
  }

  if (missing(data)){
    data = model.full$model
    tryCatch(update(model.full, data = data), error = function(e){
      message("Updating model fit failed. Try rerunning with providing data argument")})
  }
  else{
    data = as.data.frame(data)
  }

  # point estimation
  output <- list(alpha = alpha, nboot = nboot, boot.method = "nonparam")
  output = c(output, resi_pe(model.full = model.full, model.reduced = model.reduced,
                             data = data, anova = anova, coefficients = coefficients,
                             vcovfunc = vcovfunc, Anova.args = Anova.args,
                             vcov.args = vcov.args, unbiased = unbiased, ...))


  # bootstrapping
  boot_out = boot(data = data, R = nboot, statistic = resi_stat, parallel = parallel,
                  ncpus = ncpus, mod.full = model.full, mod.reduced = model.reduced,
                  anova = anova, coefficients = coefficients, vcovfunc = vcovfunc,
                  Anova.args = Anova.args, vcov.args = vcov.args, unbiased = unbiased,
                  ...)

  # bootstrapped estimates
  boot.results = boot_out$t
  colnames(boot.results) = names(boot_out$t0)

  alpha.order = sort(c(alpha/2, 1-alpha/2))
  output$overall[nrow(output$overall),paste(alpha.order*100, '%', sep='')] =
    quantile(boot.results[,1], probs = alpha.order, na.rm = TRUE)

  if (coefficients){
    CIs = apply(boot.results[,2:(1+nrow(output$coefficients))], 2,  quantile,
                probs = alpha.order, na.rm = TRUE)
    CIs = t(CIs)
    output$coefficients[1:nrow(CIs), paste(alpha.order*100, '%', sep='')] = CIs
  }

  if (anova){
    CIs = apply(boot.results[,(ncol(boot.results)-length(which(rownames(output$anova) !=
                                                             "Residuals"))+1):
                           ncol(boot.results)], 2,  quantile, probs = alpha.order, na.rm = TRUE)
    CIs = t(CIs)
    output$anova[1:nrow(CIs), paste(alpha.order*100, '%', sep='')] = CIs
  }

  if(store.boot){
    output$boot.results = boot.results
  }
  class(output) = "resi"
  return(output)
}

set.seed(123)
t1b = Sys.time()
resi_boot_obj = resi_boot(mod1, store.boot = TRUE)
t2b = Sys.time()
dtb = difftime(t2b, t1b)
dtb

resi_boot_obj
resi_internal

```

```{r}
# try to implement bayesian bootstrap
resi_bstat = function(dat, inds, mod.full){
  n = nrow(dat)
  repeat{
    # Generate the random numbers from unif(0, 1)
    u = runif(n-1)
    u.sort = sort(u)
    g = c(u.sort, 1) - c(0, u.sort)
    if (sum(g == 0) == 0) break
  } # end `repeat`
  boot.data = cbind(dat, g)
  mod = update(mod.full, data = boot.data)
  out = resi_pe(mod, data = boot.data)$estimates
  out
}

set.seed(123)
t1ba = Sys.time()
resi_internalb = resi(mod1, boot.method = "bayes",store.boot = TRUE)
t2ba = Sys.time()
dtba = difftime(t2ba, t1ba)
dtba

set.seed(123)
t1bb = Sys.time()
resi_bootb = boot(RESI::insurance, R = 1000, statistic = resi_bstat, mod.full = mod1)
t2bb = Sys.time()
dtbb = difftime(t2bb, t1bb)
dtbb
boot_cisb = apply(resi_bootb$t, 2, quantile, probs = c(0.025, 0.975))
boot_cisb
resi_internalb
```


```{r}
# trying snow option
### may not be setting snow up correctly
set.seed(123)
t1s = Sys.time()
resi_boot_snow = resi_boot(mod1, store.boot = TRUE, parallel = "snow")
t2s = Sys.time()
dts = difftime(t2s, t1s)
dts

resi_boot_snow
```


```{r}
# comparing average boot time with average internal time
boot_times = c()
internal_times = c()
boot_cis_lower = boot_cis_upper = internal_cis_lower = internal_cis_upper = data.frame()
for (i in 1:100){
  # boot
  set.seed(123)
  t1b = Sys.time()
  rboot = resi_boot(mod1, store.boot = TRUE, parallel = "snow")
  t2b = Sys.time()
  dtb = difftime(t2b, t1b)
  boot_times = c(boot_times, dtb)
  # confidence intervals
  bcis = apply(rboot$boot.results, 2, quantile, probs = c(0.025, 0.975))
  boot_cis_lower = rbind(boot_cis_lower, bcis[1,])
  boot_cis_upper = rbind(boot_cis_upper, bcis[2,])
  
  # internal
  set.seed(123)
  t1i = Sys.time()
  rint = resi(mod1, store.boot = T)
  t2i = Sys.time()
  dti = difftime(t2i, t1i)
  internal_times = cbind(internal_times, dti)
  icis = apply(resi_internal$boot.results, 2, quantile, probs = c(0.025, 0.975))
  internal_cis_lower = rbind(internal_cis_lower, icis[1,])
  internal_cis_upper = rbind(internal_cis_upper, icis[2,])
} 
avgtime_boot = mean(boot_times)
avgtime_internal = mean(internal_times)
avg_boot_lower = colMeans(boot_cis_lower)
avg_boot_upper = colMeans(boot_cis_upper)
avg_internal_lower = colMeans(internal_cis_lower)
avg_internal_upper = colMeans(internal_cis_upper)

avgtime_boot
avgtime_internal
avg_boot_lower - avg_internal_lower
avg_boot_upper - avg_internal_upper
```
